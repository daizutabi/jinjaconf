{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jinjaconf Documentation","text":"<p>Jinja2-based text generation from configuration objects.</p> <p>Jinjaconf provides a flexible and powerful way to generate text from configuration objects using Jinja2 templates. It allows for easy creation, updating, and rendering of configuration objects, with support for custom methods and dynamic content.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jinjaconf\n</code></pre>"},{"location":"usage/hydra/","title":"Hydra application","text":""},{"location":"api/jinjaconf/","title":"jinjaconf","text":"jinjaconf<p> source package jinjaconf </p> <p>Jinja2-based text generation from configuration objects.</p> <p>Provide a flexible and powerful way to generate text from configuration objects using Jinja2 templates. It allows for easy creation, updating, and rendering of configuration objects, with support for custom methods and dynamic content.</p> <p> Classes </p> <ul> <li> <p>BaseConfig \u2014 Represent a base configuration for text.</p> </li> </ul> <p> source dataclass BaseConfig(_template_: str | Path = '') </p> <p><p>Bases : Renderable</p></p> <p>Represent a base configuration for text.</p> <p>This class provides a structure for storing configuration parameters and methods for updating and rendering text based on templates.</p> <p> Attributes </p> <ul> <li> <p>_template_ :  str \u2014 The name of the template file.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>update \u2014 Update the configuration in-place with new values.</p> </li> <li> <p>render \u2014 Render text from the specified configuration.</p> </li> </ul> <p> source classmethod BaseConfig.update(cfg: Self) \u2192 None </p> <p>Update the configuration in-place with new values.</p> <p>This method should be overridden by subclasses to update configuration parameters before rendering the template.</p> <p> Parameters </p> <ul> <li> <p>cfg :  BaseConfig \u2014 The configuration instance to be updated.</p> </li> </ul> <p> source classmethod BaseConfig.render(cfg: Self, **kwargs) \u2192 str </p> <p>Render text from the specified configuration.</p> <p>This method locates the template file, updates the configuration, and renders the text using the template and additional keyword arguments provided. It supports dynamic template methods defined in the class.</p> <p> Parameters </p> <ul> <li> <p>cfg :  BaseConfig \u2014 The configuration instance to render the text from.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to pass to the template rendering.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered text as a string.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError \u2014 If the template file does not exist in any of the searched directories.</p> </li> </ul>"},{"location":"src/jinjaconf/","title":"jinjaconf","text":"jinjaconf<p> docs package jinjaconf </p> <pre><code>\"\"\"Jinja2-based text generation from configuration objects.\n\nProvide a flexible and powerful way to generate text from\nconfiguration objects using Jinja2 templates.\nIt allows for easy creation, updating, and rendering of configuration\nobjects, with support for custom methods and dynamic content.\n\"\"\"\n\nfrom .config import BaseConfig\n\n__all__ = [\"BaseConfig\"]\n</code></pre>"},{"location":"api/jinjaconf/config/","title":"jinjaconf.config","text":"jinjaconf.config<p> source module jinjaconf.config </p> <p>Provide tools for configuration and template-based rendering.</p> <p>This module defines a base configuration class for text along with functions to locate and render templates using these configurations. It supports dynamic discovery of template methods within classes.</p> <p> Classes </p> <ul> <li> <p>Renderable \u2014 Represent a renderable class.</p> </li> <li> <p>BaseConfig \u2014 Represent a base configuration for text.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>iter_template_methods \u2014 Yield name and method pairs of template methods from a given class.</p> </li> <li> <p>is_template_method \u2014 Check if the object is a template method with specific characteristics.</p> </li> </ul> <p> source dataclass Renderable() </p> <p><p>Bases : ABC</p></p> <p>Represent a renderable class.</p> <p> Methods </p> <ul> <li> <p>render \u2014 Render the given configuration and return a string.</p> </li> </ul> <p> source classmethod Renderable.render(cfg: Self, *args, **kwargs) \u2192 str </p> <p>Render the given configuration and return a string.</p> <p> source dataclass BaseConfig(_template_: str | Path = '') </p> <p><p>Bases : Renderable</p></p> <p>Represent a base configuration for text.</p> <p>This class provides a structure for storing configuration parameters and methods for updating and rendering text based on templates.</p> <p> Attributes </p> <ul> <li> <p>_template_ :  str \u2014 The name of the template file.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>update \u2014 Update the configuration in-place with new values.</p> </li> <li> <p>render \u2014 Render text from the specified configuration.</p> </li> </ul> <p> source classmethod BaseConfig.update(cfg: Self) \u2192 None </p> <p>Update the configuration in-place with new values.</p> <p>This method should be overridden by subclasses to update configuration parameters before rendering the template.</p> <p> Parameters </p> <ul> <li> <p>cfg :  BaseConfig \u2014 The configuration instance to be updated.</p> </li> </ul> <p> source classmethod BaseConfig.render(cfg: Self, **kwargs) \u2192 str </p> <p>Render text from the specified configuration.</p> <p>This method locates the template file, updates the configuration, and renders the text using the template and additional keyword arguments provided. It supports dynamic template methods defined in the class.</p> <p> Parameters </p> <ul> <li> <p>cfg :  BaseConfig \u2014 The configuration instance to render the text from.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to pass to the template rendering.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered text as a string.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError \u2014 If the template file does not exist in any of the searched directories.</p> </li> </ul> <p> source iter_template_methods(cls: object) \u2192 Iterator[tuple[str, Callable[[Any], str]]] </p> <p>Yield name and method pairs of template methods from a given class.</p> <p>This function iterates over all members of a class, checks if each member is a template method using the <code>is_template_method</code> function, and yields the name and the method itself if it is a template method.</p> <p> Parameters </p> <ul> <li> <p>cls :  object \u2014 The class object whose members are to be checked for being template methods.</p> </li> </ul> <p> Yields </p> <ul> <li> <p>tuple[str, Callable[[Any], str]] \u2014 An iterator of tuples, each containing the name of the template method and the method itself.</p> </li> </ul> <p> source is_template_method(obj: object) \u2192 TypeGuard[Callable[[Any], str]] </p> <p>Check if the object is a template method with specific characteristics.</p> <p> A template method in this context is considered to be a method that </p> <ul> <li>Is a bound method of a class (not a static or free function).</li> <li>Accepts exactly one argument.</li> <li>Has a return annotation that is neither None nor missing.</li> </ul> <p> Parameters </p> <ul> <li> <p>obj :  object \u2014 The object to be inspected and verified.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>bool \u2014 True if the object is a method that matches the template method criteria, with a return annotation other than None. False otherwise.</p> </li> </ul>"},{"location":"src/jinjaconf/config/","title":"jinjaconf.config","text":"jinjaconf.config<p> docs module jinjaconf.config </p> <pre><code>\"\"\"Provide tools for configuration and template-based rendering.\n\nThis module defines a base configuration class for text along with\nfunctions to locate and render templates using these configurations.\nIt supports dynamic discovery of template methods within classes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom inspect import Signature\nfrom pathlib import Path  # noqa: TCH003\nfrom typing import TYPE_CHECKING, TypeGuard\n\nfrom .render import render\nfrom .template import get_template_file\n\nif TYPE_CHECKING:\n    from collections.abc import Callable, Iterator\n    from typing import Any, Self\n\n\n@dataclass\nclass Renderable(ABC):docs\n    \"\"\"Represent a renderable class.\"\"\"\n\n    @classmethod\n    @abstractmethod\n    def render(cls, cfg: Self, *args, **kwargs) -&gt; str:docs\n        \"\"\"Render the given configuration and return a string.\"\"\"\n\n\n@dataclass\nclass BaseConfig(Renderable):docs\n    \"\"\"Represent a base configuration for text.\n\n    This class provides a structure for storing configuration parameters\n    and methods for updating and rendering text based on templates.\n\n    Attributes:\n        _template_ (str): The name of the template file.\n\n    \"\"\"\n\n    _template_: str | Path = \"\"\n\n    @classmethod\n    def update(cls, cfg: Self) -&gt; None:docs\n        \"\"\"Update the configuration in-place with new values.\n\n        This method should be overridden by subclasses to update\n        configuration parameters before rendering the template.\n\n        Args:\n            cfg (BaseConfig): The configuration instance to be updated.\n\n        \"\"\"\n\n    @classmethod\n    def render(cls, cfg: Self, **kwargs) -&gt; str:docs\n        \"\"\"Render text from the specified configuration.\n\n        This method locates the template file, updates the configuration,\n        and renders the text using the template and additional keyword\n        arguments provided. It supports dynamic template methods defined\n        in the class.\n\n        Args:\n            cfg (BaseConfig): The configuration instance to render the\n                text from.\n            **kwargs: Additional keyword arguments to pass to the\n                template rendering.\n\n        Returns:\n            str: The rendered text as a string.\n\n        Raises:\n            FileNotFoundError: If the template file does not exist\n                in any of the searched directories.\n\n        \"\"\"\n        cls.update(cfg)\n\n        params = kwargs.copy()\n\n        for name, obj in iter_template_methods(cls):\n            if name not in params:\n                params[name] = obj(cfg)\n\n        template_file = get_template_file(cls, cfg._template_)\n        return render(template_file, cfg, **params)\n\ndocs\ndef iter_template_methods(cls: object) -&gt; Iterator[tuple[str, Callable[[Any], str]]]:\n    \"\"\"Yield name and method pairs of template methods from a given class.\n\n    This function iterates over all members of a class, checks if each member\n    is a template method using the `is_template_method` function, and yields the\n    name and the method itself if it is a template method.\n\n    Args:\n        cls (object): The class object whose members are to be checked\n            for being template methods.\n\n    Yields:\n        tuple[str, Callable[[Any], str]]: An iterator of tuples, each\n        containing the name of the template method and the method\n        itself.\n\n    \"\"\"\n    members = inspect.getmembers(cls)\n    for name, obj in members:\n        if not name.startswith(\"_\") and is_template_method(obj):\n            yield name, obj\n\n\ndef is_template_method(obj: object) -&gt; TypeGuard[Callable[[Any], str]]:docs\n    \"\"\"Check if the object is a template method with specific characteristics.\n\n    A template method in this context is considered to be a method that:\n    - Is a bound method of a class (not a static or free function).\n    - Accepts exactly one argument.\n    - Has a return annotation that is neither None nor missing.\n\n    Args:\n        obj (object): The object to be inspected and verified.\n\n    Returns:\n        bool: True if the object is a method that matches the template\n        method criteria, with a return annotation other than None.\n        False otherwise.\n\n    \"\"\"\n    if not inspect.ismethod(obj) or not inspect.isclass(obj.__self__):\n        return False\n\n    signature = inspect.signature(obj)\n    if signature.return_annotation in [None, \"None\", Signature.empty]:\n        return False\n\n    return len(signature.parameters) == 1\n</code></pre>"},{"location":"api/jinjaconf/render/","title":"jinjaconf.render","text":"jinjaconf.render<p> source module jinjaconf.render </p> <p>Provide utilities for loading and rendering Jinja2 templates.</p> <p>Leverage the omegaconf library for configuration management. It is designed to facilitate the dynamic generation of content based on template files and configurable context parameters.</p> <p> Functions </p> <ul> <li> <p>load_template \u2014 Load a Jinja2 template from the specified file.</p> </li> <li> <p>render \u2014 Render a Jinja2 template with the given context.</p> </li> </ul> <p> source load_template(template_file: str | Path) \u2192 Template </p> <p>Load a Jinja2 template from the specified file.</p> <p> Parameters </p> <ul> <li> <p>template_file :  str | Path \u2014 The path to the template file.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Template \u2014 The loaded Jinja2 template.</p> </li> </ul> <p> source render(template_file: str | Path, cfg: object | None = None, **kwargs) \u2192 str </p> <p>Render a Jinja2 template with the given context.</p> <p>Take a template file and a configuration object or dictionary, and renders the template with the provided context. Additional context can be passed as keyword arguments.</p> <p> Parameters </p> <ul> <li> <p>template_file :  str | Path \u2014 The path to the template file.</p> </li> <li> <p>cfg :  object | None \u2014 The configuration object or dictionary to use as context for rendering the template. If configuration is not an instance of DictConfig, it will be converted using OmegaConf.structured.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to include in the template context.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The rendered template as a string.</p> </li> </ul>"},{"location":"src/jinjaconf/render/","title":"jinjaconf.render","text":"jinjaconf.render<p> docs module jinjaconf.render </p> <pre><code>\"\"\"Provide utilities for loading and rendering Jinja2 templates.\n\nLeverage the omegaconf library for configuration management.\nIt is designed to facilitate the dynamic generation of content\nbased on template files and configurable context parameters.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\nfrom omegaconf import DictConfig, OmegaConf\n\nif TYPE_CHECKING:\n    from jinja2 import Template\n\n\ndef load_template(template_file: str | Path) -&gt; Template:docs\n    \"\"\"Load a Jinja2 template from the specified file.\n\n    Args:\n        template_file (str | Path): The path to the template file.\n\n    Returns:\n        Template: The loaded Jinja2 template.\n\n    \"\"\"\n    path = Path(template_file).absolute().resolve()\n    loader = FileSystemLoader(path.parent)\n    env = Environment(loader=loader, autoescape=select_autoescape([\"jinja2\"]))\n\n    return env.get_template(path.name)\n\ndocs\ndef render(template_file: str | Path, cfg: object | None = None, **kwargs) -&gt; str:\n    \"\"\"Render a Jinja2 template with the given context.\n\n    Take a template file and a configuration object or dictionary,\n    and renders the template with the provided context. Additional context can be\n    passed as keyword arguments.\n\n    Args:\n        template_file (str | Path): The path to the template file.\n        cfg (object | None): The configuration object or dictionary to use as context\n            for rendering the template. If configuration is not an instance of\n            DictConfig, it will be converted using OmegaConf.structured.\n        **kwargs: Additional keyword arguments to include in the template context.\n\n    Returns:\n        str: The rendered template as a string.\n\n    \"\"\"\n    if not cfg:\n        cfg = {}\n    elif not isinstance(cfg, DictConfig):\n        cfg = OmegaConf.structured(cfg)\n\n    template = load_template(template_file)\n    return template.render(cfg, **kwargs)\n</code></pre>"},{"location":"api/jinjaconf/template/","title":"jinjaconf.template","text":"jinjaconf.template<p> source module jinjaconf.template </p> <p>Template file handling.</p> <p> Functions </p> <ul> <li> <p>get_template_file \u2014 Return the path to a template file associated with a given class.</p> </li> </ul> <p> source get_template_file(cls: object, filename: str | Path, dir: str | Path = 'templates') \u2192 Path </p> <p>Return the path to a template file associated with a given class.</p> <p>This function searches for a template file with the specified name, first in the current directory, then in the provided directory, and finally in the directory relative to the module where the class is defined. If the file is not found, a FileNotFoundError is raised.</p> <p> Parameters </p> <ul> <li> <p>cls :  object \u2014 The class object associated with the template file. It is used to determine the relative path if the template file is not found in the current or provided directory.</p> </li> <li> <p>filename :  str | Path \u2014 The name of the template file.</p> </li> <li> <p>dir :  str | Path, optional \u2014 The directory where the template files are stored. Defaults to \"templates\".</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Path \u2014 The absolute path to the template file.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>FileNotFoundError \u2014 If the template file does not exist in any of the searched directories.</p> </li> </ul>"},{"location":"src/jinjaconf/template/","title":"jinjaconf.template","text":"jinjaconf.template<p> docs module jinjaconf.template </p> <pre><code>\"\"\"Template file handling.\"\"\"\n\nimport inspect\nfrom pathlib import Path\n\n\ndef get_template_file(docs\n    cls: object,\n    filename: str | Path,\n    dir: str | Path = \"templates\",  # noqa: A002\n) -&gt; Path:\n    \"\"\"Return the path to a template file associated with a given class.\n\n    This function searches for a template file with the specified name,\n    first in the current directory, then in the provided directory,\n    and finally in the directory relative to the module where the class\n    is defined. If the file is not found, a FileNotFoundError is raised.\n\n    Args:\n        cls (object): The class object associated with the template file. It is\n            used to determine the relative path if the template file is not\n            found in the current or provided directory.\n        filename (str | Path): The name of the template file.\n        dir (str | Path, optional): The directory where the template files\n            are stored. Defaults to \"templates\".\n\n    Returns:\n        Path: The absolute path to the template file.\n\n    Raises:\n        FileNotFoundError: If the template file does not exist in any of the\n            searched directories.\n\n    \"\"\"\n    file = Path(filename)\n\n    if file.exists():\n        return file.absolute()\n\n    file_ = dir / file\n    if file_.exists():\n        return file_.absolute()\n\n    from_dir = Path(inspect.getfile(cls)).parent  # type: ignore\n    return _get_template_file_from_dir(file, dir, from_dir).absolute()\n\n\ndef _get_template_file_from_dir(file: Path, dir: str | Path, from_dir: Path) -&gt; Path:  # noqa: A002\n    file_ = from_dir / file\n    if file_.exists():\n        return file_\n\n    file_ = from_dir / dir / file\n    if file_.exists():\n        return file_\n\n    if from_dir.parent != from_dir:\n        return _get_template_file_from_dir(file, dir, from_dir.parent)\n\n    raise FileNotFoundError\n</code></pre>"},{"location":"api/jinjaconf/testing/","title":"jinjaconf.testing","text":"jinjaconf.testing<p> source module jinjaconf.testing </p> <p>Test the rendering process of configuration objects and their results.</p> <p>This module provides test utilities to assert that the rendering process of a configuration object produces the expected output. It is designed to be used in test suites to verify that the configuration and rendering mechanisms are functioning correctly.</p> <p> Functions </p> <ul> <li> <p>assert_render_in \u2014 Assert that a rendered text contains a substring.</p> </li> <li> <p>assert_render_eq \u2014 Assert that a rendered text is equal to the expected string.</p> </li> <li> <p>assert_render_startswith \u2014 Assert that a rendered text starts with the expected string.</p> </li> <li> <p>assert_render_endswith \u2014 Assert that a rendered text ends with the expected string.</p> </li> </ul> <p> source assert_render_in(cfg: Renderable, expected: str | list[str], *args, **kwargs) \u2192 None </p> <p>Assert that a rendered text contains a substring.</p> <p>This function takes a configuration object, renders a text using the configuration's class render method, and then asserts that the expected substring is present in the rendered text. It performs this check twice: once with the original configuration object and once with a configuration object converted to a dictionary using OmegaConf.</p> <p> Parameters </p> <ul> <li> <p>cfg :  BaseConfig \u2014 The configuration object to render the text from.</p> </li> <li> <p>expected :  str | list[str] \u2014 The substring that must be present in the rendered text.</p> </li> <li> <p>*args \u2014 Additional positional arguments to pass to the <code>render</code> function.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to pass to the <code>render</code> function.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AssertionError \u2014 If the expected substring is not found in the rendered text for either the original configuration object or the OmegaConf dictionary configuration.</p> </li> </ul> <p> source assert_render_eq(cfg: Renderable, expected: str, *args, **kwargs) \u2192 None </p> <p>Assert that a rendered text is equal to the expected string.</p> <p>This function takes a configuration object, renders a text using the configuration's class render method, and then asserts that the rendered text is equal to the expected string. It performs this check twice: once with the original configuration object and once with a configuration object converted to a dictionary using OmegaConf.</p> <p> Parameters </p> <ul> <li> <p>cfg :  Renderable \u2014 The configuration object to render the text from.</p> </li> <li> <p>expected :  str \u2014 The string that the rendered text must match.</p> </li> <li> <p>*args \u2014 Additional positional arguments to pass to the <code>render</code> function.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to pass to the <code>render</code> function.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AssertionError \u2014 If the rendered text does not match the expected string for either the original configuration object or the OmegaConf dictionary configuration.</p> </li> </ul> <p> source assert_render_startswith(cfg: Renderable, expected: str, *args, **kwargs) \u2192 None </p> <p>Assert that a rendered text starts with the expected string.</p> <p>This function takes a configuration object, renders a text using the configuration's class render method, and asserts that the rendered text starts with the specified string. It performs this check twice: once with the original configuration object and once with a configuration object converted to a dictionary using OmegaConf.</p> <p> Parameters </p> <ul> <li> <p>cfg :  Renderable \u2014 The configuration object to render the text from.</p> </li> <li> <p>expected :  str \u2014 The string that the rendered text must start with.</p> </li> <li> <p>*args \u2014 Additional positional arguments to pass to the <code>render</code> method.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to pass to the <code>render</code> method.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AssertionError \u2014 If the rendered text does not start with the expected string for either the original configuration object or the OmegaConf dictionary configuration.</p> </li> </ul> <p> source assert_render_endswith(cfg: Renderable, expected: str, *args, **kwargs) \u2192 None </p> <p>Assert that a rendered text ends with the expected string.</p> <p>This function takes a configuration object, renders a text using the configuration's class render method, and asserts that the rendered text ends with the specified string. It performs this check twice: once with the original configuration object and once with a configuration object converted to a dictionary using OmegaConf.</p> <p> Parameters </p> <ul> <li> <p>cfg :  Renderable \u2014 The configuration object to render the text from.</p> </li> <li> <p>expected :  str \u2014 The string that the rendered text must end with.</p> </li> <li> <p>*args \u2014 Additional positional arguments to pass to the <code>render</code> method.</p> </li> <li> <p>**kwargs \u2014 Additional keyword arguments to pass to the <code>render</code> method.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AssertionError \u2014 If the rendered text does not end with the expected string for either the original configuration object or the OmegaConf dictionary configuration.</p> </li> </ul>"},{"location":"src/jinjaconf/testing/","title":"jinjaconf.testing","text":"jinjaconf.testing<p> docs module jinjaconf.testing </p> <pre><code>\"\"\"Test the rendering process of configuration objects and their results.\n\nThis module provides test utilities to assert that the rendering\nprocess of a configuration object produces the expected output.\nIt is designed to be used in test suites to verify that the configuration\nand rendering mechanisms are functioning correctly.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom omegaconf import OmegaConf\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n\n    from jinjaconf.config import Renderable\n\n\ndef _assert_render(\n    cfg: Renderable,\n    expected: str | list[str],\n    callback: Callable[[str, str], None],\n    *args,\n    **kwargs,\n) -&gt; None:\n    if isinstance(expected, str):\n        expected = [expected]\n\n    dc = OmegaConf.structured(cfg)\n    cls = type(cfg)\n\n    for config in [cfg, dc]:\n        text = cls.render(config, *args, **kwargs)\n        for ex in expected:\n            callback(text, ex)\n\n\ndef assert_render_in(docs\n    cfg: Renderable,\n    expected: str | list[str],\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Assert that a rendered text contains a substring.\n\n    This function takes a configuration object, renders a text using the\n    configuration's class render method, and then asserts that the expected\n    substring is present in the rendered text. It performs this check twice:\n    once with the original configuration object and once with a configuration\n    object converted to a dictionary using OmegaConf.\n\n    Args:\n        cfg (BaseConfig): The configuration object to render the text from.\n        expected (str | list[str]): The substring that must be present in the\n            rendered text.\n        *args: Additional positional arguments to pass to the `render` function.\n        **kwargs: Additional keyword arguments to pass to the `render` function.\n\n    Raises:\n        AssertionError: If the expected substring is not found in the rendered\n            text for either the original configuration object or the OmegaConf\n            dictionary configuration.\n\n    \"\"\"\n\n    def callback(text: str, expected: str) -&gt; None:\n        if expected not in text:\n            msg = (\n                \"The rendered text is missing the expected substring.\\n\"\n                \"Missing substring:\\n\"\n                f\"{expected!r}\\n\"\n                \"Rendered text:\\n\"\n                f\"{text!r}\"\n            )\n            raise AssertionError(msg)\n\n    _assert_render(cfg, expected, callback, *args, **kwargs)\n\n\ndef assert_render_eq(docs\n    cfg: Renderable,\n    expected: str,\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Assert that a rendered text is equal to the expected string.\n\n    This function takes a configuration object, renders a text using the\n    configuration's class render method, and then asserts that the rendered\n    text is equal to the expected string. It performs this check twice:\n    once with the original configuration object and once with a configuration\n    object converted to a dictionary using OmegaConf.\n\n    Args:\n        cfg (Renderable): The configuration object to render the text from.\n        expected (str): The string that the rendered text must match.\n        *args: Additional positional arguments to pass to the `render` function.\n        **kwargs: Additional keyword arguments to pass to the `render` function.\n\n    Raises:\n        AssertionError: If the rendered text does not match the expected\n            string for either the original configuration object or the\n            OmegaConf dictionary configuration.\n\n    \"\"\"\n\n    def callback(text: str, expected: str) -&gt; None:\n        if expected != text:\n            msg = (\n                \"The rendered text does not match the expected string.\\n\"\n                \"Expected:\\n\"\n                f\"{expected!r}\\n\"\n                \"Rendered:\\n\"\n                f\"{text!r}\"\n            )\n            raise AssertionError(msg)\n\n    _assert_render(cfg, expected, callback, *args, **kwargs)\n\n\ndef assert_render_startswith(docs\n    cfg: Renderable,\n    expected: str,\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Assert that a rendered text starts with the expected string.\n\n    This function takes a configuration object, renders a text using the\n    configuration's class render method, and asserts that the rendered text\n    starts with the specified string. It performs this check twice: once with\n    the original configuration object and once with a configuration object\n    converted to a dictionary using OmegaConf.\n\n    Args:\n        cfg (Renderable): The configuration object to render the text from.\n        expected (str): The string that the rendered text must start with.\n        *args: Additional positional arguments to pass to the `render` method.\n        **kwargs: Additional keyword arguments to pass to the `render` method.\n\n    Raises:\n        AssertionError: If the rendered text does not start with the\n            expected string for either the original configuration object or\n            the OmegaConf dictionary configuration.\n\n    \"\"\"\n\n    def callback(text: str, expected: str) -&gt; None:\n        if not text.startswith(expected):\n            msg = \"Rendered text does not start with the expected \"\n            msg += f\"string: {expected!r}, but it starts with \"\n            msg += f\"{text[:len(expected)]!r} instead.\"\n            raise AssertionError(msg)\n\n    _assert_render(cfg, expected, callback, *args, **kwargs)\n\n\ndef assert_render_endswith(docs\n    cfg: Renderable,\n    expected: str,\n    *args,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Assert that a rendered text ends with the expected string.\n\n    This function takes a configuration object, renders a text using the\n    configuration's class render method, and asserts that the rendered text\n    ends with the specified string. It performs this check twice: once with\n    the original configuration object and once with a configuration object\n    converted to a dictionary using OmegaConf.\n\n    Args:\n        cfg (Renderable): The configuration object to render the text from.\n        expected (str): The string that the rendered text must end with.\n        *args: Additional positional arguments to pass to the `render` method.\n        **kwargs: Additional keyword arguments to pass to the `render` method.\n\n    Raises:\n        AssertionError: If the rendered text does not end with the\n            expected string for either the original configuration object or\n            the OmegaConf dictionary configuration.\n\n    \"\"\"\n\n    def callback(text: str, expected: str) -&gt; None:\n        if not text.endswith(expected):\n            msg = \"Rendered text does not end with the expected \"\n            msg += f\"string: {expected!r}, but it ends with \"\n            msg += f\"{text[-len(expected):]!r} instead.\"\n            raise AssertionError(msg)\n\n    _assert_render(cfg, expected, callback, *args, **kwargs)\n</code></pre>"}]}